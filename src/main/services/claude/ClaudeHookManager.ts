import * as fs from 'node:fs';
import * as os from 'node:os';
import * as path from 'node:path';

interface ClaudeSettings {
  hooks?: {
    Stop?: Array<{
      matcher?: string;
      hooks: Array<{
        type: 'command' | 'prompt';
        command?: string;
        prompt?: string;
        timeout?: number;
      }>;
    }>;
    [key: string]: unknown;
  };
  [key: string]: unknown;
}

const HOOK_MARKER = 'EnsoAI-StopHook';

function getClaudeConfigDir(): string {
  if (process.env.CLAUDE_CONFIG_DIR) {
    return process.env.CLAUDE_CONFIG_DIR;
  }
  return path.join(os.homedir(), '.claude');
}

function getClaudeSettingsPath(): string {
  return path.join(getClaudeConfigDir(), 'settings.json');
}

function getHooksDir(): string {
  return path.join(getClaudeConfigDir(), 'hooks');
}

function getHookScriptPath(): string {
  return path.join(getHooksDir(), 'ensoai-stop.js');
}

function getElectronPathFile(): string {
  return path.join(getHooksDir(), '.ensoai-electron-path');
}

/**
 * Write current Electron executable path to a file for hook script to use
 */
function writeElectronPath(): void {
  const hooksDir = getHooksDir();
  if (!fs.existsSync(hooksDir)) {
    fs.mkdirSync(hooksDir, { recursive: true, mode: 0o755 });
  }
  fs.writeFileSync(getElectronPathFile(), process.execPath, { mode: 0o644 });
}

/**
 * Node.js hook script content - runs on all platforms using Electron's Node
 */
function getHookScriptContent(): string {
  const ideDir = path.join(getClaudeConfigDir(), 'ide');
  // Use forward slashes for path in JS (works on all platforms)
  const ideDirJs = ideDir.replace(/\\/g, '/');

  return `// EnsoAI Stop Hook - Sends precise agent completion notifications
// Auto-generated by EnsoAI - Do not edit manually
// Runs with ELECTRON_RUN_AS_NODE=1

const fs = require('fs');
const path = require('path');
const http = require('http');

const IDE_DIR = '${ideDirJs}';

async function main() {
  // Read JSON from stdin
  let input = '';
  process.stdin.setEncoding('utf8');
  for await (const chunk of process.stdin) {
    input += chunk;
  }

  let sessionId;
  try {
    const data = JSON.parse(input);
    sessionId = data.session_id;
  } catch {
    process.exit(0);
  }

  if (!sessionId) {
    process.exit(0);
  }

  // Find EnsoAI lockfile
  if (!fs.existsSync(IDE_DIR)) {
    process.exit(0);
  }

  const lockfiles = fs.readdirSync(IDE_DIR).filter(f => f.endsWith('.lock'));
  for (const lockfile of lockfiles) {
    try {
      const content = JSON.parse(fs.readFileSync(path.join(IDE_DIR, lockfile), 'utf-8'));
      if (content.ideName === 'EnsoAI') {
        const port = path.basename(lockfile, '.lock');
        // Send POST request
        const postData = JSON.stringify({ session_id: sessionId });
        const req = http.request({
          hostname: '127.0.0.1',
          port: parseInt(port),
          path: '/agent-stop',
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Content-Length': Buffer.byteLength(postData),
          },
          timeout: 2000,
        });
        req.on('error', () => {});
        req.write(postData);
        req.end();
        break;
      }
    } catch {
      // Ignore errors, try next lockfile
    }
  }
}

main().catch(() => process.exit(0));
`;
}

/**
 * Ensure hook script file and Electron path file exist
 */
function ensureHookScript(): string {
  const hooksDir = getHooksDir();
  const scriptPath = getHookScriptPath();

  // Create hooks directory if needed
  if (!fs.existsSync(hooksDir)) {
    fs.mkdirSync(hooksDir, { recursive: true, mode: 0o755 });
  }

  // Write script file
  fs.writeFileSync(scriptPath, getHookScriptContent(), { mode: 0o755 });

  // Write Electron path for hook to use
  writeElectronPath();

  return scriptPath;
}

/**
 * Generate hook command that runs the script using Electron's Node runtime
 */
function generateHookCommand(): string {
  const isWindows = process.platform === 'win32';
  const electronPathFile = getElectronPathFile();
  const scriptPath = getHookScriptPath();

  // Use forward slashes for cross-platform compatibility
  const electronPathFileCmd = electronPathFile.replace(/\\/g, '/');
  const scriptPathCmd = scriptPath.replace(/\\/g, '/');

  if (isWindows) {
    // PowerShell: read electron path and execute with ELECTRON_RUN_AS_NODE
    return `powershell -NoProfile -Command "$electron = Get-Content '${electronPathFileCmd}' -Raw; $env:ELECTRON_RUN_AS_NODE = '1'; & $electron.Trim() '${scriptPathCmd}'"`;
  } else {
    // Bash: read electron path and execute with ELECTRON_RUN_AS_NODE
    return `ELECTRON_RUN_AS_NODE=1 "$(cat '${electronPathFileCmd}')" "${scriptPathCmd}"`;
  }
}

/**
 * Check if EnsoAI Stop hook is already configured
 */
function isHookConfigured(settings: ClaudeSettings): boolean {
  const stopHooks = settings.hooks?.Stop;
  if (!Array.isArray(stopHooks)) return false;

  return stopHooks.some((hookGroup) =>
    hookGroup.hooks?.some((hook) => hook.type === 'command' && hook.command?.includes(HOOK_MARKER))
  );
}

/**
 * Ensure the Stop hook is configured in Claude settings
 * Returns true if hook was added or already exists
 */
export function ensureStopHook(): boolean {
  try {
    // Always ensure script file is up-to-date
    ensureHookScript();

    const settingsPath = getClaudeSettingsPath();

    // Read existing settings or create new
    let settings: ClaudeSettings = {};
    if (fs.existsSync(settingsPath)) {
      const content = fs.readFileSync(settingsPath, 'utf-8');
      settings = JSON.parse(content);
    }

    // Check if already configured
    if (isHookConfigured(settings)) {
      return true;
    }

    // Initialize hooks object if needed
    if (!settings.hooks) {
      settings.hooks = {};
    }
    if (!settings.hooks.Stop) {
      settings.hooks.Stop = [];
    }

    // Add our hook with a marker comment in the command
    const hookCommand = generateHookCommand();
    settings.hooks.Stop.push({
      matcher: '',
      hooks: [
        {
          type: 'command',
          // Include marker so we can identify our hook later
          command: `# ${HOOK_MARKER}\n${hookCommand}`,
          timeout: 5,
        },
      ],
    });

    // Ensure directory exists
    const configDir = getClaudeConfigDir();
    if (!fs.existsSync(configDir)) {
      fs.mkdirSync(configDir, { recursive: true, mode: 0o700 });
    }

    // Write settings
    fs.writeFileSync(settingsPath, JSON.stringify(settings, null, 2), {
      mode: 0o600,
    });

    console.log('[ClaudeHookManager] Stop hook configured successfully');
    return true;
  } catch (error) {
    console.error('[ClaudeHookManager] Failed to configure Stop hook:', error);
    return false;
  }
}

/**
 * Remove EnsoAI Stop hook from Claude settings
 */
export function removeStopHook(): boolean {
  try {
    const settingsPath = getClaudeSettingsPath();

    if (!fs.existsSync(settingsPath)) {
      return true;
    }

    const content = fs.readFileSync(settingsPath, 'utf-8');
    const settings: ClaudeSettings = JSON.parse(content);

    if (!settings.hooks?.Stop) {
      return true;
    }

    // Filter out our hooks
    settings.hooks.Stop = settings.hooks.Stop.filter(
      (hookGroup) =>
        !hookGroup.hooks?.some(
          (hook) => hook.type === 'command' && hook.command?.includes(HOOK_MARKER)
        )
    );

    // Clean up empty arrays
    if (settings.hooks.Stop.length === 0) {
      delete settings.hooks.Stop;
    }
    if (Object.keys(settings.hooks).length === 0) {
      delete settings.hooks;
    }

    fs.writeFileSync(settingsPath, JSON.stringify(settings, null, 2), {
      mode: 0o600,
    });

    console.log('[ClaudeHookManager] Stop hook removed successfully');
    return true;
  } catch (error) {
    console.error('[ClaudeHookManager] Failed to remove Stop hook:', error);
    return false;
  }
}
